## 内部碎片与外部碎片的区别
内部碎片和外部碎片都是指存储分配的碎片，但它们的来源和性质不同。

内部碎片指的是已经分配给某个进程的一块内存空间中，未被利用的部分。例如，如果一个进程需要分配 20KB 的内存空间，但是只有一个 24KB 的内存块可用，那么分配给该进程的内存块会有 4KB 的内部碎片。

外部碎片指的是还没有分配给任何进程的零散的内存空间。这些空间可能太小，无法满足某些大内存需求，因此它们被认为是浪费的内存。外部碎片通常由多次内存分配和释放操作造成，从而导致内存空间变得零散。

总体而言，内部碎片是进程使用已分配内存时的浪费，而外部碎片是未被分配利用的内存空间造成的浪费。

## Q2
针对如下生成二进制的过程。编译器用于生成每个模块的目标代码，而链接编辑器用于将多个目标模块合并为一个二进制程序。
链接编辑器如何改变指令和数据到内存地址的绑定?需要将什么信息从编译器传递给链接编辑器，以协助链接编辑器完成内存绑定任务?
在链接编辑器将多个目标模块合并为一个二进制程序时，需要将这些模块中的指令和数据绑定到正确的内存地址。这个过程称为链接，它包括符号解析、重定位和文件合并等步骤。链接编辑器可以通过以下方式改变指令和数据到内存地址的绑定：

- 符号解析：链接编辑器会遍历所有的目标模块，解析符号表中的符号，即变量名、函数名等，以确定每个符号所代表的地址。

- 重定位：链接编辑器将在符号解析后，将各个模块中的指令和数据的相对地址转换为绝对地址，即确定它们在最终二进制程序中的实际内存地址。

- 文件合并：链接编辑器将所有的目标模块中的指令和数据按照正确的顺序组合到一个二进制文件中，以便最终生成可执行程序。

为了协助链接编辑器完成内存绑定任务，编译器需要将一些信息传递给链接编辑器。这些信息包括：

- 符号表：编译器生成每个目标模块时，会生成一个符号表，其中包含了模块中所有的变量名、函数名等符号以及它们的地址或偏移量信息。这些符号表会被传递给链接编辑器，以便在链接时进行符号解析和重定位。

- 重定位信息：编译器在生成目标模块时，会将指令和数据的相对地址信息保存下来，以便在链接时进行重定位。这些重定位信息也会被传递给链接编辑器，以便进行指令和数据的地址转换。

- 外部符号引用：如果一个模块需要使用另一个模块中定义的变量或函数，编译器会生成外部符号引用信息，并将其传递给链接编辑器。链接编辑器在符号解析时，会用这些信息在其他模块中查找所需的符号。

- 段信息：编译器将每个目标模块中的代码和数据分别放置在不同的段中，每个段都有一个起始地址和长度。这些段信息也会被传递给链接编辑器，以便进行文件合并和内存布局。

## Q3
大多数系统允许程序在执行时可以为自己的地址空间分配更多的内存。程序的堆段(heap segment)的数据分配就是这样一个内存分配的实例。在下面方案中，支持动态内存分配需要什么?
a.连续内存分配
b.纯分段
c.纯分页

支持动态内存分配需要连续内存分配或纯分页的方案。而纯分段的方案不太适合动态内存分配，因为分配的数据可能会随着时间的推移而变得不连续，从而导致内存碎片的问题。以下是对每种方案的简要说明：

- a. 连续内存分配：动态内存分配需要程序在运行时分配更多的内存。连续内存分配允许程序在需要时增加其地址空间，即通过增加堆段的大小来分配更多的内存。在这种方案中，程序使用的内存是连续的，因此内存管理比较容易。

- b. 纯分段：在纯分段方案中，程序的地址空间被划分为多个不同的段，每个段可以有不同的大小和位置。虽然这种方案允许程序更灵活地使用内存，但它不太适合动态内存分配，因为分配的数据可能会随着时间的推移而变得不连续，从而导致内存碎片的问题。

- c. 纯分页：在纯分页方案中，程序的地址空间被划分为多个大小相等的页面，每个页面可以独立地被映射到物理内存中的任何位置。这种方案对于动态内存分配是很有用的，因为它允许程序动态地分配和释放页面，而不会导致内存碎片的问题。同时，纯分页方案也提供了虚拟内存的功能，使得程序的地址空间可以大于物理内存大小，从而增加了程序的可用内存空间。

综上所述，连续内存分配和纯分页方案都可以支持动态内存分配，而纯分段方案则不太适合。

## Q4
针对以下问题，比较连续内存分配、纯分段和纯分页的内存组织方案:
- a.外部碎片
- b.内部碎片
- c.能够跨进程共享代码

a. 外部碎片：连续内存分配和纯分段方案都可能导致外部碎片的问题，因为它们都需要使用连续的内存块。在连续内存分配中，如果有许多小的空闲内存块散布在整个内存中，则可能无法将它们合并为一个大的连续内存块，从而导致外部碎片。而在纯分段方案中，不同的段可能会占用内存的不同部分，从而导致未使用的内存碎片化。相比之下，纯分页方案不会出现外部碎片问题，因为每个页面都是大小相等的。

b. 内部碎片：连续内存分配和纯分段方案都可能导致内部碎片问题。在连续内存分配中，由于每个内存块的大小是固定的，因此可能会分配比需要更多的内存，从而导致内部碎片。而在纯分段方案中，每个段的大小是固定的，因此可能会分配比需要更大的内存，从而导致内部碎片。相比之下，纯分页方案不太容易出现内部碎片问题，因为页面的大小可以根据需要调整。

c. 能够跨进程共享代码：在连续内存分配和纯分段方案中，不同的进程可能使用相同的代码段，因为它们可以在不同的进程之间共享相同的物理内存块。相比之下，纯分页方案可能会使得相同的代码段存在于不同的页面中，从而导致无法跨进程共享代码。为了解决这个问题，现代的操作系统通常使用基于页面的内存管理，即将代码段映射到相同的物理页面中，从而允许不同的进程共享代码段。

综上所述，连续内存分配和纯分段方案可能会出现外部碎片和内部碎片问题，并且能够跨进程共享代码，而纯分页方案不会出现外部碎片问题，不太容易出现内部碎片问题，但可能无法跨进程共享代码。
